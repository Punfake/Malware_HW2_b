import argparse
import lief
import os
import subprocess


def align(x, al):
    """ return <x> aligned to <al> """
    if x % al == 0:
        return x
    else:
        return x - (x % al) + al


def pad_data(data, al):
    """ return <data> padded with 0 to a size aligned with <al> """
    return data + ([0] * (align(len(data), al) - len(data)))

def pack_data(data) :
    KEY = 0xAA
    result = [0] * len(data)
    for i in range(0, len(data)):
        KEY = data[i] ^ KEY
        result[i] = KEY
    return result


if __name__ =="__main__" :

    parser = argparse.ArgumentParser(description='Pack PE binary')
    parser.add_argument('input', metavar="FILE", help='input file')
    parser.add_argument('-o', metavar="FILE", help='output', default="packed.exe")

    args = parser.parse_args()

    # Mở file input (Putty.exe)
    input_PE = lief.PE.parse(args.input)

    # Mở file unpack.exe
    unpack_PE = lief.PE.parse("unpack.exe")

    # Ta giữ nguyên agliment của file unpack, vì sau đây ta sẽ
    # chỉnh sử trên file này để trở thành file output 
    file_alignment = unpack_PE.optional_header.file_alignment
    section_alignment = unpack_PE.optional_header.section_alignment

    # Gán output bằng file unpack
    output_PE = unpack_PE

    # Tạo .packed section từ file Putty :

    # Đọc file Putty lên
    with open(args.input, "rb") as f:
        input_PE_data = f.read()

    
    packed_data = pack_data(list(input_PE_data)) # Biến packed_data tạm lưu các section
    packed_data = pad_data(packed_data, file_alignment) # Đóng gói (nén và mã hóa packed_data)

    # Tạo các trường của section bằng thư viện lief
    packed_section = lief.PE.Section(".packed")
    packed_section.content =  packed_data
    packed_section.size = len(packed_data)
    packed_section.characteristics = (lief.PE.SECTION_CHARACTERISTICS.MEM_READ
                                    | lief.PE.SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA)
    # Add section .packed mới tạo vào fild output
    output_PE.add_section(packed_section)

    # set sizeOfImage = 0, thông số này sẽ thay đổi sau khi thêm section
    # nhưng không cần tính toán vì lief sẽ hỗ trợ phần này
    output_PE.optional_header.sizeof_image = 0


    # Lưu lại những thay đổi, xóa file để ghi đè nếu file đã tồn tại
    if(os.path.exists(args.o)):
        os.remove(args.o)

    # Ghi file output
    builder = lief.PE.Builder(output_PE)
    builder.build()
    builder.write(args.o)


    